---
description: AI Migration Tool — Cursor agent rules
globs: ["**/*.py", "**/*.yaml", "**/*.md", "agent-prompts/**"]
alwaysApply: true
---

# AI Migration Tool — Cursor Agent Rules

You are assisting with the **AI Migration Tool** — a multi-agent pipeline that
migrates `HAB-GPRSSubmission` (Angular 2 / ASP.NET Core) to a modern target stack.

---

## Running a migration

**Always use `run_agent.py` to run migrations — never call `main.py` directly
from the agent chat.** Each migration job is defined in a YAML file under
`agent-prompts/`. The agent's job is to pick the right file and run it.

### List available jobs
```bash
python run_agent.py --list-jobs
```

### Run a job
```bash
python run_agent.py --job agent-prompts/migrate-action-history.yaml
```

### Common overrides (append to any run command)
```bash
--dry-run       # Simulate the run, write no files
--force         # Re-run even if the feature was already migrated
--auto-approve  # Skip the human approval gate (testing only)
--verbose       # Show DEBUG-level logs
--mode full     # Override pipeline.mode without editing the YAML
--json          # Machine-readable JSON output for agent parsing
```

### Examples
```bash
# Plan only — generate Plan Document, no code
python run_agent.py --job agent-prompts/migrate-action-history.yaml

# Full pipeline — plan + code conversion
python run_agent.py --job agent-prompts/migrate-action-history.yaml --mode full

# Override mode at the CLI without editing YAML
python run_agent.py --job agent-prompts/migrate-action-history.yaml --mode scope

# Dry run to preview without writing files
python run_agent.py --job agent-prompts/migrate-action-history.yaml --dry-run
```

---

## Agent-interactive commands (Cursor / Windsurf / Copilot / AntiGravity)

These commands enable fully autonomous, non-interactive agent-driven migration.

### 1. Discover available features in the source codebase
```bash
python run_agent.py --list-features --source <YOUR_SOURCE_ROOT>
python run_agent.py --list-features --json   # returns JSON list for agent parsing
```

### 2. Create a job file without human prompts
```bash
python run_agent.py --new-job \
  --feature ActionHistory \
  --target snake_case \
  --non-interactive \
  --json
```
`--feature` resolves as: absolute path → source-relative path → folder name auto-match
against `detect_feature_folders()`.

### 3. Generate the plan (no code written)
```bash
python run_agent.py --job agent-prompts/migrate-actionhistory-snake_case.yaml
```

### 4. Check migration status
```bash
python run_agent.py --status --job agent-prompts/migrate-actionhistory-snake_case.yaml --json
```
Returns: `plan_generated`, `plan_approved`, `conversion_started`,
`completed_steps`, `pending_steps`, `blocked_steps`, next-step advice.

### 5a. Approve the plan and run conversion (no TTY required)
```bash
python run_agent.py --approve-plan \
  --job agent-prompts/migrate-actionhistory-snake_case.yaml

python run_agent.py --job agent-prompts/migrate-actionhistory-snake_case.yaml \
  --mode full
```
`--approve-plan` writes `output/<feature>/.approved` — the pipeline detects it
and auto-skips the interactive terminal prompt.

### 5b. Revise the plan with LLM feedback (clears approval)
```bash
python run_agent.py --revise-plan \
  --job agent-prompts/migrate-actionhistory-snake_case.yaml \
  --feedback "Add a DB migration section. Flag pfm-auth imports as BLOCKED."
```
- Reuses the cached dependency graph (`logs/{run_id}-dependency-graph.json`)
- Writes a `-rev.md` revised plan file
- Removes the `.approved` marker so the revised plan requires explicit re-approval
- After revision: re-run `--approve-plan`, then `--mode full`

### Full autonomous workflow example
```bash
# 1. Discover features
python run_agent.py --list-features --json

# 2. Create job (non-interactive)
python run_agent.py --new-job --feature ActionHistory --target snake_case \
                    --non-interactive --json

# 3. Generate plan
python run_agent.py --job agent-prompts/migrate-actionhistory-snake_case.yaml

# 4. Check status
python run_agent.py --status \
  --job agent-prompts/migrate-actionhistory-snake_case.yaml --json

# 5a. Approve + convert
python run_agent.py --approve-plan \
  --job agent-prompts/migrate-actionhistory-snake_case.yaml
python run_agent.py --job agent-prompts/migrate-actionhistory-snake_case.yaml \
  --mode full

# 5b. Or: revise, re-approve, re-convert
python run_agent.py --revise-plan \
  --job agent-prompts/migrate-actionhistory-snake_case.yaml \
  --feedback "Flag pfm-auth imports. Expand data-access section."
python run_agent.py --approve-plan \
  --job agent-prompts/migrate-actionhistory-snake_case.yaml
python run_agent.py --job agent-prompts/migrate-actionhistory-snake_case.yaml \
  --mode full
```

---

## Configuring a new migration target (first-time setup)

If the user wants to migrate to a **new or custom stack** (not `simpler_grants`,
`hrsa_pprs`, or `snake_case`), run the **Setup Wizard** to generate optimised prompts
and config:

```bash
# Interactive — walks you through source/target codebase questions
python run_agent.py --setup

# With pre-filled answers (agent / CI friendly)
python run_agent.py --setup --config agent-prompts/example-wizard-config.json

# Preview what would be generated without writing files
python run_agent.py --setup --dry-run

# List all configured targets
python run_agent.py --setup --list-targets
```

The wizard produces:
- `prompts/plan_system_<target_id>.txt` — custom LLM plan prompt
- `prompts/conversion_system_<target_id>.txt` — custom LLM conversion prompt
- `prompts/conversion_target_stack_<target_id>.txt` — target stack reference
- `agent-prompts/_template_<target_id>.yaml` — ready-to-fill job template
- Updates `config/skillset-config.json` with the new target/source stack entries
- Updates `config/wizard-registry.json` (idempotency guard)

After setup, copy the template and run as normal:
```bash
cp agent-prompts/_template_<target_id>.yaml agent-prompts/migrate-<FeatureName>.yaml
# edit: set pipeline.feature_root and pipeline.feature_name
python run_agent.py --job agent-prompts/migrate-<FeatureName>.yaml
```

---

## Creating a new job file (for an existing target)

### Option A — Agent/non-interactive
```bash
python run_agent.py --new-job \
  --feature MyFeature --target snake_case \
  --non-interactive --json
```

### Option B — Manual
Fill in:
- `pipeline.feature_root` — absolute path to the legacy feature folder
- `pipeline.feature_name` — human-readable name (used in filenames)
- `pipeline.mode` — `plan` (recommended first run) or `full`
- `pipeline.target` — target identifier (e.g. `simpler_grants`, `hrsa_pprs`, `snake_case`)

```bash
# Then run it
python run_agent.py --job agent-prompts/migrate-<FeatureName>.yaml
```

---

## Project structure (do not modify these)

```
main.py                    # Core pipeline — do NOT invoke directly in agent mode
run_agent.py               # Agent entry point — READ job file, run pipeline
setup_wizard.py            # First-run setup wizard (also via run_agent.py --setup)
wizard/                    # Setup wizard modules (detector, collector, generator, ...)
agent-prompts/             # YAML job files — one per migration job
  _template.yaml           # Blank template (simpler_grants / hrsa_pprs targets)
  _template_<id>.yaml      # Custom template generated by setup_wizard.py
  migrate-*.yaml           # Filled-in job files
  example-wizard-config.json  # Sample wizard answers for non-interactive mode
agents/                    # Pipeline agents (read-only unless fixing bugs)
prompts/                   # LLM prompt files (safe to edit for tuning)
config/                    # skillset-config.json + rules-config.json
  wizard-registry.json     # Registry of targets configured by setup_wizard.py
templates/                 # Jinja2 code scaffolds
plans/                     # Generated Plan Documents (output — do not edit)
logs/                      # Dependency graphs + conversion logs (output)
output/                    # Generated converted code (output)
checkpoints/               # Run state for resume (output)
```

---

## Key rules

1. **Never call `main.py` directly** from agent chat — always use `run_agent.py --job <file>`.
2. **Never modify files under `plans/`, `logs/`, `output/`, `checkpoints/`** — these are pipeline outputs.
3. **Never edit `config/skillset-config.json` or `config/rules-config.json`** unless the user explicitly asks.
4. **Prompt files** under `prompts/` are safe to read and suggest edits for — they control LLM behaviour.
5. **If the feature already has a completed run**, the pipeline will say "Already Complete — Skipping". Use `--force` to re-run.
6. **Mode `plan` is the safe default** — generates a Plan Document without writing converted code. Always start here for new features.
7. **Human approval gate**: in `full` mode, a human types `yes` OR use `--approve-plan` for agent-based approval (writes `.approved` marker).
8. **Plan revision**: use `--revise-plan --feedback "..."` to regenerate with LLM feedback — automatically clears the `.approved` marker.

---

## Supported target stacks

| `target` value | Stack |
|---|---|
| `simpler_grants` | Next.js 15 / React 19 / APIFlask / SQLAlchemy 2.0 |
| `hrsa_pprs` | Next.js 16 / React 18 / Flask 3.0 / psycopg2 raw SQL |
| `snake_case` | Next.js / TypeScript / Flask 3.0 / snake_case naming |
| `<custom>` | Configured via `python run_agent.py --setup` |

---

## LLM configuration

The tool auto-detects the LLM provider from environment variables:
```
ANTHROPIC_API_KEY   → Anthropic Claude (recommended)
OPENAI_API_KEY      → OpenAI GPT
OLLAMA_MODEL        → Ollama local server
LLM_BASE_URL        → OpenAI-compatible (LM Studio, vLLM)
LLAMACPP_MODEL_PATH → Local GGUF file
```

Set `llm.no_llm: true` in the job file (or pass `--no-llm`) for template-only
scaffold mode that requires no API key.

### LLM failure behaviour

| Run context | Behaviour on LLM error |
|---|---|
| Via `run_agent.py` (Cursor Agent, etc.) | **Soft-fail** — returns Jinja2 template scaffold so Cursor can continue |
| Via `main.py` directly (CLI/human) | **Hard-fail** — raises `LLMConfigurationError` with actionable fix instructions |

`run_agent.py` sets `AI_AGENT_MODE=1` automatically before the pipeline runs.
You can also force agent mode in any terminal session:
```bash
set AI_AGENT_MODE=1       # Windows CMD
$env:AI_AGENT_MODE=1      # PowerShell
export AI_AGENT_MODE=1    # bash/zsh
```

---

## When asked to "migrate a feature"

### Human-assisted mode
1. Ask (or check): which feature folder and which target stack?
2. Check configured targets: `python run_agent.py --setup --list-targets`
3. If the target does not exist yet, run the setup wizard first
4. Check if a job file already exists: `ls agent-prompts/migrate-<name>*.yaml`
5. If not, copy the right template: `cp agent-prompts/_template_<target>.yaml agent-prompts/migrate-<name>.yaml`
6. Run in plan mode first: `python run_agent.py --job agent-prompts/<file>.yaml`
7. Show the user the generated plan path and ask them to review it
8. Only run `full` mode after the user has reviewed and approved the plan

### Autonomous agent mode (Cursor, Windsurf, Copilot, AntiGravity)
```bash
python run_agent.py --list-features --json
python run_agent.py --new-job --feature <Name> --target snake_case --non-interactive --json
python run_agent.py --job agent-prompts/migrate-<name>-snake_case.yaml
python run_agent.py --status --job agent-prompts/migrate-<name>-snake_case.yaml --json
python run_agent.py --approve-plan --job agent-prompts/migrate-<name>-snake_case.yaml
python run_agent.py --job agent-prompts/migrate-<name>-snake_case.yaml --mode full
```

## When asked to "configure a new target" or "set up migration for X to Y"

1. Run the setup wizard: `python run_agent.py --setup`
2. For agent / non-interactive mode, prepare a JSON config first:
   `cp agent-prompts/example-wizard-config.json agent-prompts/wizard-<target_id>.json`
   Edit the JSON with the actual source/target details, then:
   `python run_agent.py --setup --config agent-prompts/wizard-<target_id>.json --non-interactive`
3. Review the generated prompts in `prompts/` and adjust if needed
4. The job template will be at `agent-prompts/_template_<target_id>.yaml`
